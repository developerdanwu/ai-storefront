---
description: Guidelines and best practices for building Convex projects, including database schema design, queries, mutations, and real-world examples
globs: convex/**/*.ts
---

# Convex Guidelines for ai-storefront

## Project-Specific Patterns

### File Organization
This project organizes Convex functions by domain in folders:
```
convex/
├── _generated/         # Auto-generated files (do not edit)
├── agents/             # AI agent definitions and middleware
│   ├── models.ts       # AI model configurations
│   ├── storeAgent.ts   # Main store agent
│   └── middleware/     # Agent middleware
├── ai/                 # AI-related functions
│   ├── query.ts        # Public queries
│   ├── mutation.ts     # Public mutations (if any)
│   ├── action.ts       # Public actions
│   └── actionsNode.ts  # Node.js runtime actions
├── helpers/            # Reusable helper functions
├── lib/                # Test fixtures and utilities
├── marketing/          # Marketing-related functions
├── schema/             # Schema definitions per table
├── users/              # User-related functions
│   ├── query.ts
│   ├── mutation.ts
│   └── nodeAction.ts
├── convex.config.ts    # Component configuration
├── errors.ts           # Typed error factories
├── http.ts             # HTTP endpoints
├── procedures.ts       # Custom function wrappers
├── rag.ts              # RAG configuration
├── rateLimiter.ts      # Rate limiter configuration
└── schema.ts           # Main schema file
```

### Schema Definition Pattern
Use `convex-helpers/server` `Table` helper for schema definitions. Define each table in `convex/schema/*.schema.ts`:

```typescript
// convex/schema/users.schema.ts
import { Table } from "convex-helpers/server";
import { type Infer, v } from "convex/values";

export type User = Infer<typeof Users.doc>;

export const Users = Table("users", {
  isAnonymous: v.boolean(),
  email: v.optional(v.string()),
  externalId: v.optional(v.string()),
  firstName: v.union(v.string(), v.null()),
  lastName: v.union(v.string(), v.null()),
  emailVerified: v.boolean(),
  profilePictureUrl: v.optional(v.union(v.string(), v.null())),
});
```

Then import into `convex/schema.ts`:
```typescript
// convex/schema.ts
import { defineSchema } from "convex/server";
import { Users } from "./schema/users.schema";
import { AiAgentPersona } from "./schema/aiAgentPersona.schema";

const schema = defineSchema({
  users: Users.table
    .index("externalId", ["externalId"])
    .index("email", ["email"]),
  aiAgentPersona: AiAgentPersona.table.index("agentId", ["agentId"]),
});

export default schema;
```

### Custom Procedures Pattern
Use custom procedures from `convex/procedures.ts` instead of raw `query`/`mutation`/`action`:

```typescript
// For authenticated users
import { authedQuery, authedMutation, authedAction } from "../procedures";

export const getThreads = authedQuery({
  args: { paginationOpts: paginationOptsValidator },
  handler: async (ctx, args) => {
    // ctx.user is automatically available and typed
    return getAiThreads(ctx, {
      userId: ctx.user._id,
      paginationOpts: args.paginationOpts,
    });
  },
});

// For anonymous users (requires anonymousUserId in args)
import { anonymousQuery, anonymousAction } from "../procedures";

export const getAnonymousThreads = anonymousQuery({
  args: { paginationOpts: paginationOptsValidator },
  handler: async (ctx, args) => {
    // ctx.user is the anonymous user (may be null)
    if (!ctx.user) return emptyResult;
    return getAiThreads(ctx, { userId: ctx.user._id, ... });
  },
});
```

Available custom procedures:
- `authedQuery` - Query requiring authenticated user, provides `ctx.user`
- `authedMutation` - Mutation requiring authenticated user, provides `ctx.user`
- `authedAction` - Action requiring authenticated user, provides `ctx.user`
- `anonymousQuery` - Query for anonymous users, accepts `anonymousUserId` arg
- `anonymousAction` - Action for anonymous users, provides `ctx.anonymousUserId`

### Error Handling with neverthrow
Use `neverthrow` library with `ResultAsync` for functional error handling:

```typescript
// convex/errors.ts - Define typed error factories
export type BackendErrorSchema = {
  _tag: string;
  context: ErrorContext;
};

type ErrorContext = {
  message: string;
  error?: unknown;
  [key: string]: any;
};

export function userNotFound(context: ErrorContext) {
  return {
    _tag: "UserNotFound",
    context,
  } as const satisfies BackendErrorSchema;
}

export function rateLimitExceeded(
  context: ErrorContext & { retryAfter: number; name: string }
) {
  return {
    _tag: "RateLimitExceeded",
    context,
  } as const satisfies BackendErrorSchema;
}
```

Using in handlers:
```typescript
import { ConvexError } from "convex/values";
import { ResultAsync } from "neverthrow";
import * as Errors from "../errors";

export const someAction = authedAction({
  args: { ... },
  handler: async (ctx, args) => {
    return await someHelper(ctx, args).match(
      (result) => result,
      (error) => {
        throw new ConvexError(error);
      }
    );
  },
});
```

### Helper Functions Pattern
Create reusable helpers in `convex/helpers/` that return `ResultAsync`:

```typescript
// convex/helpers/getUser.ts
import { Infer, v } from "convex/values";
import { ResultAsync } from "neverthrow";
import { QueryCtx } from "../_generated/server";
import * as Errors from "../errors";

export const VGetUserArgs = v.object({
  workosUserId: v.string(),
});

export type TGetUserArgs = Infer<typeof VGetUserArgs>;

export function getUser(
  ctx: QueryCtx,
  { args }: { args: TGetUserArgs }
) {
  return ResultAsync.fromPromise(
    ctx.db
      .query("users")
      .withIndex("externalId", (q) => q.eq("externalId", args.workosUserId))
      .first()
      .then((r) => {
        if (!r) {
          throw Errors.userNotFound({
            message: `User with id: ${args.workosUserId} not found`,
          });
        }
        return r;
      }),
    (e) =>
      Errors.userNotFound({
        message: `User with id: ${args.workosUserId} not found`,
      })
  );
}
```

### Convex Components Configuration
Components are configured in `convex/convex.config.ts`:

```typescript
import cache from "@convex-dev/action-cache/convex.config";
import agent from "@convex-dev/agent/convex.config";
import rag from "@convex-dev/rag/convex.config";
import rateLimiter from "@convex-dev/rate-limiter/convex.config";
import resend from "@convex-dev/resend/convex.config";
import workflow from "@convex-dev/workflow/convex.config";
import { defineApp } from "convex/server";

const app = defineApp();
app.use(agent);
app.use(workflow);
app.use(rag);
app.use(cache);
app.use(rateLimiter);
app.use(resend);
export default app;
```

Access components via:
```typescript
import { components } from "../_generated/api";

// Example: Using agent component
await ctx.runQuery(components.agent.threads.listThreadsByUserId, { ... });
await ctx.runAction(components.agent.threads.deleteAllForThreadIdSync, { ... });
```

### Rate Limiting
Configure rate limits in `convex/rateLimiter.ts`:

```typescript
import { MINUTE, RateLimitConfig, RateLimiter } from "@convex-dev/rate-limiter";
import { components } from "./_generated/api";

const limitConfig = {
  sendAIMessage: { kind: "fixed window", rate: 10, period: MINUTE },
  createAiThread: { kind: "fixed window", rate: 5, period: MINUTE },
} as const satisfies Record<string, RateLimitConfig>;

export type RateLimitName = keyof typeof limitConfig;
export const rateLimiter = new RateLimiter(components.rateLimiter, limitConfig);
```

Use via helper:
```typescript
import { rateLimit } from "../helpers/rateLimit";

await rateLimit(ctx, {
  name: "createAiThread",
  key: ctx.user._id,
}).match(
  (x) => x,
  (e) => { throw new ConvexError(e); }
);
```

### AI Agent Pattern
Define agents in `convex/agents/`:

```typescript
// convex/agents/storeAgent.ts
import { Agent, createTool } from "@convex-dev/agent";
import { wrapLanguageModel } from "ai";
import z from "zod";
import { components } from "../_generated/api";
import { rag } from "../rag";
import { grok3Mini } from "./models";

export const createStoreAgent = (args = {}) => {
  return new Agent(components.agent, {
    chat: wrapLanguageModel({
      model: grok3Mini,
      middleware: args.middleware ?? [],
    }),
    name: "Store agent",
    maxSteps: 10,
    instructions: `Your agent instructions here...`,
    tools: {
      searchCurriculumVitae: createTool({
        args: z.object({
          query: z.string().describe("The query to search with"),
        }),
        handler: async (ctx, args) => {
          return await ResultAsync.fromPromise(
            rag.search(ctx, { namespace: "cv", query: args.query }),
            () => Errors.aiToolFailure({ message: "Search failed" })
          ).match(
            (x) => ({ success: true, value: x.entries }),
            (e) => ({ success: false, error: e })
          );
        },
      }),
    },
  });
};
```

### RAG Configuration
Configure RAG in `convex/rag.ts`:

```typescript
import { cohere } from "@ai-sdk/cohere";
import { RAG } from "@convex-dev/rag";
import { components } from "./_generated/api";

type FilterTypes = {};

export const rag = new RAG<FilterTypes>(components.rag, {
  textEmbeddingModel: cohere.embedding("embed-english-v3.0"),
  embeddingDimension: 1024,
});
```

### AI Models
Define AI models in `convex/agents/models.ts`:

```typescript
import { xai } from "@ai-sdk/xai";

export const grok4 = xai("grok-4-0709");
export const grok3 = xai("grok-3");
export const grok3Mini = xai("grok-3-mini");
```

---

## General Convex Guidelines

### Function Syntax
ALWAYS use the new function syntax for Convex functions:
```typescript
import { query } from "./_generated/server";
import { v } from "convex/values";

export const f = query({
  args: {},
  returns: v.null(),
  handler: async (ctx, args) => {
    // Function body
  },
});
```

### HTTP Endpoint Syntax
HTTP endpoints are defined in `convex/http.ts`:
```typescript
import { httpRouter } from "convex/server";
import { httpAction } from "./_generated/server";

const http = httpRouter();

http.route({
  path: "/workos-webhook",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    const bodyText = await request.text();
    // Handle webhook
    return new Response(null, { status: 200 });
  }),
});

export default http;
```

### Validators
- Always use `v.null()` when returning a null value
- Use `v.union()` for optional nullable fields: `v.union(v.string(), v.null())`
- Use `v.optional()` for truly optional fields: `v.optional(v.string())`

Valid Convex types:
| Type    | TS/JS type  | Validator                    |
|---------|-------------|------------------------------|
| Id      | string      | `v.id(tableName)`            |
| Null    | null        | `v.null()`                   |
| Int64   | bigint      | `v.int64()`                  |
| Float64 | number      | `v.number()`                 |
| Boolean | boolean     | `v.boolean()`                |
| String  | string      | `v.string()`                 |
| Bytes   | ArrayBuffer | `v.bytes()`                  |
| Array   | Array       | `v.array(values)`            |
| Object  | Object      | `v.object({prop: value})`    |
| Record  | Record      | `v.record(keys, values)`     |

### Function Registration
- Use `internalQuery`, `internalMutation`, `internalAction` for private functions
- Use `query`, `mutation`, `action` for public functions
- ALWAYS include argument and return validators
- Internal function names should be prefixed with underscore: `_upsertFromWorkos`

### Function Calling
- Use `ctx.runQuery` to call a query from a query, mutation, or action
- Use `ctx.runMutation` to call a mutation from a mutation or action
- Use `ctx.runAction` to call an action from an action
- All calls take a `FunctionReference` - use `api.path.function` or `internal.path.function`

### Pagination
```typescript
import { paginationOptsValidator } from "convex/server";

export const listItems = query({
  args: { paginationOpts: paginationOptsValidator },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("items")
      .order("desc")
      .paginate(args.paginationOpts);
  },
});
```

Returns: `{ page, isDone, continueCursor }`

### Query Guidelines
- Do NOT use `filter` in queries - use `withIndex` instead
- Use `.unique()` for single document queries
- Use `.first()` when you expect 0 or 1 result
- Convex queries do NOT support `.delete()` - collect and delete individually

### Mutation Guidelines
- Use `ctx.db.replace` to fully replace a document
- Use `ctx.db.patch` to shallow merge updates

### Action Guidelines
- Add `"use node";` at top of files using Node.js modules
- Never use `ctx.db` inside actions - actions don't have database access
- Use `ctx.runQuery`/`ctx.runMutation` to interact with the database

### TypeScript Guidelines
- Use `Id<'tableName'>` for document IDs
- Use `Doc<'tableName'>` for full document types
- Be strict with types around document IDs
